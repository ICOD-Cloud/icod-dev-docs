# Методы API

Теперь нам нужно создать метод API. Другими словами URL на который будет сделаться `POST` запрос.

Хочу сразу сказать что API ICOD сделан не по технологии REST API. ICOD утилизирует идеологию JSON API. Она гибче и универсальней. Если интересно доп чтиво, [смотрите тут](http://habrahabr.ru/post/265845/).

Для создания запросов нужно понимать следующее:

- ICOD API принимает только запросы `POST`
- Все параметры для исполняемого метода должны передаваться в теле запроса `POST` как JSON.
- Обязательно отравить заголовок `Content Type: application/json`.
- ICOD API всегда вернет HTTP код 200 даже если будет ошибка. Просто при ошибке ключ `error` будет `true` и остальное содержать данные ошибки.
- Есть несколько параметров которые веб приложение передает с каждым запросом.
  - `lang` - Выбранный пользователем язык интерфейса.
  - `client` - Клиент веб приложения это может быть веб браузер, мобильное приложение или настольное приложение. Этот параметр используется для определения авторизации конкретного устройства.
  - `auth_uid` - ID пользователя авторизованно в данный момент времени. Если вы делает запросы которые требуют авторизации или работу с ACL этот параметр будет использован для проверки прав доступа.
  - `auth_token` - Подпись авторизации пользователя. Что бы ее получить, выполните метод API `users/profile/login` в первую очередь. Потом воспользуйтесь подписью которая будет создана в таблице `user_token`.

## Создаем новый метод

Что бы создать метод запусти команду

```bash
icod method users manage view
```

Где

- `users` - имя модуля.
- `manage` - имя группы методов API.
- `view` - имя самого метода.

Если вы видите сообщение об успешном выполнении, вы можете перейти в папку `modules/users/Api/Manage/` и там вы найдете созданные файлы. Урл для этого метода будет `users/manage/view`.

Будет создано 2 файла.

### View.php

```php
<?php
namespace Users\Api\Manage;

if(!defined('_API')) exit;

class View extends \App\Lib\Api {
    public function execute(){
        // make DB calls and return array or object
    }
}
```

Вот что нужно понимать об этом файле

1. Namespace должно быть `[Имя модуля]\Api\[Имя группы методов]`.
2. Имя класса должно соответствовать имени файла.
3. Класс должен наследовать от `\App\Lib\Api`.
4. В классе должен быть как минимум метод `execute()`.

Ну и теперь вы можете внутри метода `execute()` делать все что вы хотите. Вы можете вернуть строку, объект, массив или `1` что бы просто сообщить об успешном завершении.

### View.api.json

Этот файл заслуживает особого внимания. Понимание этого файла может сохранить вам много времени работы. Не забудьте посмотреть основы работы с [JSON тут](json.md).

Этот файл имеет 2 основных назначения.

1. **Документация** - На основе этих файлов генерируется автоматическая документация, так что вы как разработчик всегда знаете все методы которые только есть в ICOD. Вы знаете как из запустить, что им передать и так далее.

2. **Валидация** - Автоматическая проверка и фильтрация передаваемых параметров. В конечном итоге вам не нужно проверять переданные параметры и в методе `execute()` вы можете просто исполнять логику, вместо того что бы писать кучу кода по проверке входных данных.

> Метод API будет работать и без этого фала. Он не обязательный сам по себе. Но естественно вам нужно будет самостоятельно все проверить.

Вот пример файла.

```json
{
	"description": "Получаем список всех записей гостевой книги.",
	"ans": "guestbook.manage.view",
	"require_id": false,
	"params": [{}, {}],
	"errors": [{}, {}]
}
```

Описание параметров

- `description` - Обязательный. Описание метода.
- `ans` - ANS это Access Namespace. Это имя правила для автоматической проверки доступа к данному методу. Читайте о ACL [подробнее тут](acl.md).
- `require_id` - Проверяет передан ли ID или нет. В любом URI метода можно опционально передать ID. Например `/users/manage/view/12`. Этот параметр хорош в методах удаления, редактирования или просмотра отдельного документа.

  Этот параметр не только проверит обязательность данного параметра, но и осуществить проверку доступа ACL на основе прав для отдельной записи в базе если они существуют.

  Если этот параметр `true` то доступ к ID внутри метода `execute()` вы получите через `$this->id`. Вам не надо проверять есть он или нет. Если его не было до метод `execute()` даже не запуститься. Это касается автоматической проверки всех входных параметров.

- `errors` - Массив объектов JSON описывающий возможные ошибки которые этот метод может вернуть. Всего 2 параметра. Код ошибки и ее описание.

```json
{
	"code": "1",
	"description": "Не могу удалить запись гостевой книги, пока в ней есть комментарии."
}
```

- `params` - Массив объектов JSON описывающий параметры которые можно передать методу.

```json
{
	"name": "q",
	"type": "string",
	"default": "",
	"example": "green",
	"required": true,
	"description": "Search query to apply to Items list.",
	"validate": [
		{
			"name": "regex",
			"rule": "/^[a-zA-Z\\-]*$/iU"
		}
	],
	"filter": [
		{
			"name": "single",
			"rule": "trim,strtolower"
		}
	]
}
```

Для доступа к параметрам в `execute()` используйте метод `get` где первый параметр это имя параметра и второй значение по умолчанию.

```php
$this->get('limit', 10);
```

Значение по умолчанию будет назначено только если самого параметра не было передано. Если параметр был передан и он пуст, то метод гет это и вернет. Если параметр был помечен как `required` то можно не вводить значение по умолчанию, так как он обязательно там будет.

- `name` - Имя параметра. Это ключ который будет добавлен в тело JSON отправляемого на точку доступа.
- `type` - Тип параметра. Может быть string, boolen, integer, ... Нет ни какой магии за этим параметром, это только для документации.
- `default` - Значение по умолчанию. Здесь есть магия. Если выполните `$this->get('q')` а параметр `q` был пуст, то вы получите значение которое прописали тут.
- `example` - Чисто для документации пример как может выглядеть значение параметра.
- `required` - Проверит обязательность данного параметра. Проверит после фильтрации. Другими словами если параметр обязательный вы можете смело использовать `$this->get('q')` и быть уверенным что там есть значение.
- `description` - Опять же для документации.
- `validate` - Массив валидаторов которые нужно применить к параметру. Валидаторы применяются после фильтрации.
- `filter` - Массив фильтров которые должны применится к парамеру перед тем как любые проверки к нему применятся.

## Встроенные фильтры

Все фильтры содержатся в файле `modules\App\Lib\Api\Filters.php`.

- `preg_replace` - Заменяет по регулярному выражению. Например почистить переменную что бы в ней были только цифры.

```json
{
	"name": "preg_replace",
	"rule": {
		"from": "/^[^0-9]*$/iU",
		"to": ""
	}
}
```

- `replace` - Простая строковая замена

```json
{
	"name": "replace",
	"rule": {
		"from": "sun",
		"to": "moon"
	}
}
```

- `single` - это стандартные методы PHP которые принимают один параметре и возвращают обработанный такие как `trim()`, `ucfirst()` и т.д. Можно назначить несколько таких методов в одном фильтре просто разделив их запятой. Они исполнятся ровно в том порядке в котором записаны.

```json
{
	"name": "single",
	"rule": "trim,strtolower"
}
```

- `ids` - проверяет что параметр передает массив из целых чисел.

```json
{
	"name": "ids"
}
```

- `bool` - превращает парамер в переменную типа булева.

```json
{
	"name": "bool"
}
```

- `int` - Удаляет из параметра все символы кроме цифр и `.` при этом заменяет `,` на `.`. Если в параметр попадет `25,12` то фильтр вернет `25.12`. Но сам тип переменной преобразован не будет и останется строкой.

```json
{
	"name": "int"
}
```

- `digits` - Удаляет из параметра все символы кроме цифр.

```json
{
	"name": "digits"
}
```

## Встроенные валидаторы

Кроме валидаторов описанных ниже, есть валидатор `required`.

Валидаторы хранятся в файле `modules\App\Lib\Api\Validators.php`.

- `regex` - Проверяет параметр по регулярному выражению.

```json
{
	"name": "regex",
	"rule": "/^[a-zA-Z\\-]*$/iU"
}
```

- `number` - Проверяет что параметр это число и содержит только цифры

```json
{
	"name": "number"
}
```

- `user` - Проверяет валидность пользователя. Допустим один из параметров это ID пользователя. Этот валидатор проверит что такой пользователь действительно существует.

```json
{
	"name": "user"
}
```

## Расширение валидации и фильтрации

Допустим вам нужно создать свой собственный фильтр или валидатор. Это возможно. Для начала определитесь, этот фильтр или валидатор, может быть полезен другим? Если да то можно расширить файлы библиотеки чтобы новые валидаторы и фильтры стали доступны всем.

Если вам нужно создать валидатор или фильтр для отдельной точки доступа, тогда вы можете создать метод прямо в классе точки доступа.

Чтобы вы не вписали в `name` потом создайте в своем классе API метод `prefix_[name]` где префикс это или `validate_` или `filter_`.

Например вы хотите создать фильтр который проверит наличие категории при добавлении записи в гостевую книгу. Вот что вы можете определить в JSON точки доступа в списке `validate`.

```json
{
	"name": "cat_exists",
	"rule": {}
}
```

Теперь в классе объявите метод.

```php
<?php
namespace Guestbook\Api\Manage;

if(!defined('_API')) exit;

class View extends \App\Lib\Api {
    public function execute(){
        // make DB calls and return array or object
    }

    public function validate_cat_exists($value, $rule)
    {
        if(!\Guestbook\Models\Categories::find($value))
        {
            return false;
        }
        return true;
    }
}
```

Первый параметр `$value` это само значение передаваемого методу API параметра, а второе это то что содержится в `rule` в JSON. Так что для одного валидатора вы можете для разных параметров, создавать разные правила валидации.

Тоже самое применимо и к фильтрации, только вернуть нужно отфильтрованное значение.

Ели вы хотите иметь возможность использовать свои фильтры и валидаторы снова и снова в разных точках доступа, создайте файл `****/Lib/Filters.php` или `****/Lib/Validatprs.php` если они еще не созданы, где `****` это имя модуля. В нем создайте класс и добавьте все методы типа `validate_cat_exists` столько валидаторов и фильтров сколько захотите.

Чтобы эти фильтры и валидаторы стали доступны, нужно расширить класс точки доступа API этим новым классом. Это можно сделать 2мя способами.

1. В классе точки доступа апи добавьте метод `__construct`.

```php
function __construct()
{
    $this->extends[] = new \Users\Lib\Filters();
}
```

2. В JSON файле метода API добавьте свойство `extend`. Это просто массив из строк, с полным путем к классу где содержаться методы валидации или фильтрации.

```json
{
	"description": "Получаем список всех записей гостевой книги.",
	"ans": "Users.manage.view",
	"extend": ["\\Users\\Lib\\Filters"],
	"require_id": false,
	"params": [{}, {}],
	"errors": [{}, {}]
}
```
