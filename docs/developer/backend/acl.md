# Как работает ACL

Так как Ulacos - это приложение с единой точкой входа для всех пользователей (нет разделения на вход в админку и вход на лицевую сторону сайта). При таком подходе, правильное и надежное распределение прав становится критичным.

## Трудности

Существует несколько основных проблем связанных с ACL.

- **Трудность понимания** - Как правило ACL это самая сложная для понимания сфера как для того администратора, кто его настраивает, так и для разработчиков кто его внедряет в свое расширение\модуль.

    Это связано в основном с тем что нет единых стандартов по структурированию ACL и все внедряют эту фичу по своему, поэтому не просто понять по какой логике правила применяются к пользователям.

- **Производительность** - Анализ правил на каждом SQL запросе или запросе к АПИ, создает дополнительные нагрузки. А производительность Ulacos это одно из основных беспокойств.

Именно по этому мы постарались внедрить ACL таким образом что бы он был как можно прост для использования а особенно для внедрения.

## Структура

ACL Ulacos состоит из 3х основных сущностей, но

### 1. Роли

Можно расценивать роли как группы пользователей. В Ulacos есть 3 не удаляемые роли.

- **Все** - ID этого правила `1001`. Это не авторизованные пользователи. Настройки этой роли содержат только опции _Разрешить_ и _Запретить_ и не содержать опции _Наследовать_ так как она является корневой для всех других ролей. Всем правилам в которых не определено значение по умолчанию будет присвоено `0` или _Запретить_.

- **Пользователь** - ID этого правила `1002`. Это роль в которую автоматически попадают все только что зарегистрированные пользователи. Она является дочерней роли **Все**.

- **Супер** - ID этого правила `1000`. Это роль супер администратора. У этой роли нет настроек, все кому присвоена эта роль, автоматически получают доступ ко всему. Эта роль тоже корневая, и от нее можно тоже создать другую роль, которая унаследует все значения как `1` или _Разрешить_

Так же важно знать что все остальные роли, могут быть только дочерними. Других корневых ролей создать нельзя.

Ваша установка может содержать и другие роли. Они могут быть созданы, при загрузке конфигураций или других модулей.

### 2. Правила

Правило это соответствие значения `1` или `0` на сочетание ANS и ID пользователя.

Правила применяются к ролям и не связаны с пользователем напрямую. Поэтому всегда когда мы проверяем доступ, мы проверяем его относительно ролей а не пользователей. Ну а роли естественно привязаны к пользователям.

### 3. Пользователь

Сам пользователь, как же без него. Каждому пользователю может быть назначен несколько ролей. Не авторизованному пользователю автоматически назначается роль **Все**. При регистрации пользователю автоматически присваивается роль **Пользователь**.

## Как это работает

### ANS (Access namespace)

Прежде всего давайте разберемся что такое ANS.

Рассматривайте ANS как уникальный ключ\имя правила, но которое должно составляться следуя определенным правилам. Имя состоит из минимум 3х и максимум 4х частей разделенным точками. Вот его структура:

	[модуль].[группа].[имя].[идентификатор]

- `модуль` - имя вашего модуля
- `группа` - имя группы правил
- `имя` - имя правила
- `идентификатор` - идентификатор элемента. Например если вы хотите проверить правило на изменение записи конкретно на запись id `23`.

Например: 

	users.manage.list
	documents.manage.edit.34

2 ANS. Один проверяет можно ли получить список пользователей, а другой можно ли редактировать документ ID `34`.  

### Определение

!!! warning "Важно"
    ANS должен обязательно быть предварительно определен. Если ANS не был определен, но администратор ни когда не присвоит этому правилу значения, и его значение всегда будет `0`.

Первое что вам нужно сделать это определить все имена правил которые вы только используете в своем модуле. Это делается в файле `acl.json`.

В основном ANS привязываются к методам API, но это не значит что вы не можете определить любого другого ANS.

После определения правил, они появятся в интерфейса настройки правил администратора, и он сможет присвоить им значения на разные роли. Так что вам не нужно делать интерфейса настроек правил, а только определить список всех возможных привил.

Давайте рассмотрим пример файла `acl.json`

```json hl_lines="8 11 18 29 32 36"
{
	"name": "Продуты",
	"description": "Это правила доступа для управления продуктами.",
	"groups": [
		{
			"title": "Управление",
			"description": "",
			"ans_group_name": "goods",
			"rules": [
				{
					"ans_rule_name": "view_list",
					"defaults": {
						"1001":1
					},
					"description": "Просмотр товара в списке."
				},
				{
					"ans_rule_name": "view",
					"defaults": {
						"1002":1
					},
					"description": "Просмотр полного вида товара."
				}
			]
		},
        {
            "title": "Администрация",
			"description": "",
			"ans_group_name": "admin",
            "rules":[
                {
					"ans_rule_name": "edit",
					"description": ""
				},
				{
					"ans_rule_name": "create",
					"description": "",
				}
            ]
        }
	]
}
```

- `name` и `description` - имя и описание блока настроек правил для всего модуля включая все группы. 
- `groups` - массив куда мы добавляем группы. Группа это объект:
	- `title` - имя группы
	- `description` - описание группы
	- `ans_group_name` - имя группы для ANS (второй параметер)
	- `rules` - массив из списка правил. Каждое правило это объект:
		- `ans_rule_name` - имя правила ANS (третий параметер)
		- `description` - описание правила
		- `defaults` - значения по умолчанию

Хотя поля описаний `description` не обязательны, их нужно обязательно заполнять. Для администратора, управление правилами может превратиться в ад, если вы не оставите описаний.

Поле `defaults` содержит объект, в котором ключ, это ID роли, а значение, назначение по умолчанию. 

Так как роль **Супер** все значения `1`, то эту роль мы вообще не назначаем, так как даже если вы присвоите значение `0` это все равно будет проигнорировано.

Но так как у нас роль **Все** по умолчанию имеет все значения `0` нужно выполнять присвоение, только есл вы хотите выдать досуп и назначить `1`. 

Присвоение `1` роли **Все**, автоматически присваивает `1` роли **Пользователь** так как это роль наследует от роли **Все**.

Вы абсолютно свободны как вы будите группировать свои правила, и давать им имена. Главное чтобы ANS были только латинские буквы.

!!! hint "Заметка"
    Лучше группировать правила которые могут относиться к одной записи в базе, в одну группу.


Вот список ANS которые созданы в этом файле. Предположим имя модуля _Producs_.

	products.goods.view_list
	products.goods.view
	products.admin.edit
	products.admin.create

## Использование правил

Есть несколько сценариев когда мы хотим применить правила. Давайте рассмотрим их все по очереди.

### Доступ к методу API

Если нам нужно ограничить доступ к методу API, все что нам нужно сделать, это определить ключ `ans` в сопроводиельном фале метода `json`. Или объявить одноименное публичное свойство в калассе метода.

Например у вас есть метод `/products/admin/create` и мы создали одноименный ANS `products.admin.create`. 

```php hl_lines="10"
<?php
namespace Products\Api\Admin;

if(!defined('_API')) exit;

use App\Lib\Api;

class Create extends Api
{
	public $ans = 'products.admin.create';

	public function execute()
	{
		return true;
	}
}
```

Такой метод допустим но не лучший. Идеальный способ, объявить ANS в сопуствуюещем фале метода `json`. Для нашего примера это будет файл `modules/Producst/Api/Admin/Create.api.json`. Смотрите подробней о методах API в [стате о модулях](apiendpoint.md). 

```json hl_lines="3"
{
	"description": "Создать новый товар",
	"ans": "products.admin.create",
	"require_id": false,
	"params": [],
	"errors": [
		{
			"code": "1",
			"description": "Не все поля назначены."
		}
	]
}
```

Файлы `json` используются чтобы генерить автоматическую документацию, по API текущей установки Ulacos. Таким образом это будет не только работать, но и задокументировано.

Ulacos сам проверит есть ли у текущего пользователя права на доступ к этому методу и если нет вернет стандартный объект ошибки, который обработается на интерфейсе пользователя.

### Доступ к записи

Мы уже узнали что 4м параметром ANS может быть ID какой-то записи. Например есть ANS для просмотра продуктов `products.goods.view`. Он определяет доступ к просмотру всех продуктов в общем. Но можно и определить доступ к отдельному продукту добавив его ID. Например ANS `products.goods.view.23`.

Улакос автоматически проверит доступ к записи если в сопроводительном фале `json` метода API будет стоять параметр `"require_id": true`. Улакос возмет `ans` и ID и проверит есть ли у текущего пользователя доступ к этой записи, и если правил для отдельной записи нет, то проверит общее правило для всех записей.

У вас наверно вопрос "А как назначаются правила для отдельной записи?". Это вы узнаете когда будете изучать как создавать интерфейс. Есть компонент, который автоматически рисует группу правил и привязывает их к текущей записи. Именно по этому я советовал правила для управления одной записи группировать в одну группу. Тогда будет легко добавить ее на форму добавления или редактирования записи. 

В этой группе привил,  могут быть сразу несколько правил на редактирование, просмотр, просмотр в списке, публикацию, модерацию, удаление, ... И любые друге действия которые можно произвести с данным объектом.

#### Доступ к записи в списке

Ну одно дело определять доступ к отдельной записи при ее полном просмотре, но другое дело определять доступ к отдельной записи в списке. Ведь это необходимо сделать в самом SQL запросе а не при прорисовке списка. То есть нам нужно так расширить запрос что бы из базы были выбраны только те записи на которые нет индивидуальных правил, или правило не запрещающее.

Самостоятельно было бы не очень просто расширить свой запрос, что бы получить правильный результат. 

1. Нужно разбираться с структурой таблиц, и вникать как все устроено.
2. Таблица правил может быть достаточно большой, и как это сделать правильно что бы не повлиять на производительность, знают не все.

У Ulacos есть специальный _ScopeAcl_ который можно применить к любой модели Eloquent ORM. Для этого в вашей таблице имя поля идентификатора, обязательно должно быть `id`. И потом при получении списка просто добавте `acl()` к цепы вызовов.

```php
\Products\Models\Product::acl($this->ans, $this->user)->all();
```

!!! hint "Заметка"
	Это применимо только к запросам типа `SELECT`

`$this->ans` это то что было назначено в сопроводительном `json` файле метода API. Но это текcтовый параметр так что даже если вы не определили ANS в файле `json` вы можете вписать его в ручную как строку

	acl('products.goods.view_list', $this->user);

Удобство `ans` в файле `json` в том, что сначала Улакос автоматически првоерит доступ к самому медоду а потом примененный `acl()` уже проверит доступ по этому правил к каждой отдельной записи.

Если вы хотите проверить доступ не текущего авторизованого пользователя, а другого, вместо `$this->user` можете передать просто ID пользователя. 

#### Программынй метод

Если вы хотите где то в коде просто проверить есть ли у определнного пользователя права на определнное правило, вы можете воспользоватья помошником модуля _Acl_.

```php
<?php
if(!\Acl\Lib\Helper::hasAccess('products.admin.edit.' . $product_id, $this->user))
{
    throw new \Exception("Вы не можете редактировать эту запись");
}
```

Опять же вместо `#!php $this->user` можете передать просто ID пользователя.



